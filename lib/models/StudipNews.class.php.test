<?php
# Lifter007: TODO
# Lifter003: TEST
# Lifter010: TODO
/**
* StudipNews.class.php
*
*
*
*
* @author   André Noack <noack@data-quest>, Suchi & Berg GmbH <info@data-quest.de>
* @access   public
*/

// +---------------------------------------------------------------------------+
// This file is part of Stud.IP
//
// Copyright (C) 2005 André Noack <noack@data-quest>,
// Suchi & Berg GmbH <info@data-quest.de>
// +---------------------------------------------------------------------------+
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or any later version.
// +---------------------------------------------------------------------------+
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
// +---------------------------------------------------------------------------+

require_once 'lib/object.inc.php';

class StudipNews extends SimpleORMap {

    public static function GetNewsByRange($range_id, $only_visible = false, $as_objects = false){
        $ret = array();
        if ($only_visible){
            $clause = " AND date < UNIX_TIMESTAMP() AND (date+expire) > UNIX_TIMESTAMP() ";
        }
        $query = "SELECT news_id as idx,news.* FROM news_range
                    INNER JOIN news USING(news_id) WHERE range_id='$range_id' "
                    . $clause . " ORDER BY date DESC, chdate DESC, topic ASC";
        $rs = DBManager::get()->query($query);
        $news = $rs->fetchAll(PDO::FETCH_ASSOC|PDO::FETCH_GROUP);
        $ret = array_map('array_shift', $news);

        return ($as_objects ? StudipNews::GetNewsObjects($ret) : $ret);
    }

    public static function GetNewsByAuthor($user_id, $as_objects = false){
        $ret = array();
        $query = "SELECT news_id as idx,news.* FROM news WHERE user_id='$user_id' ORDER BY date DESC, chdate DESC";
        $rs = DBManager::get()->query($query);
        $news = $rs->fetchAll(PDO::FETCH_ASSOC|PDO::FETCH_GROUP);
        $ret = array_map('array_shift', $news);
        return ($as_objects ? StudipNews::GetNewsObjects($ret) : $ret);
    }

    public static function GetNewsByRSSId($rss_id, $as_objects = false){
        if ($user_id = StudipNews::GetUserIDFromRssID($rss_id)){
            return StudipNews::GetNewsByRange($user_id, true, $as_objects);
        } else {
            return array();
        }
    }

    public static function GetNewsObjects($news_result){
        $objects = array();
        if (is_array($news_result)){
            foreach($news_result as $id => $result){
                $objects[$id] = new StudipNews();
                $objects[$id]->setData($result, true);
                $objects[$id]->setNew(false);
            }
        }
        return $objects;
    }

    public static function GetUserIdFromRssID($rss_id){
        $ret = StudipNews::GetRangeIdFromRssID($rss_id);
        return $ret['range_id'];
    }

    public static function GetRssIdFromUserId($user_id){
        return StudipNews::GetRssIdFromRangeId($user_id);
    }

    public static function GetRangeFromRssID($rss_id){
        if ($rss_id){
            $ret = DBManager::get()
                ->query("SELECT range_id,range_type FROM news_rss_range WHERE rss_id='$rss_id'")
                ->fetch(PDO::FETCH_ASSOC);
            if (count($ret)) return $ret;
        }
        return false;
    }

    public static function GetRangeIdFromRssID($rss_id){
        $ret = StudipNews::GetRangeFromRssID($rss_id);
        return $ret['range_id'];
    }

    public static function GetRssIdFromRangeId($range_id){
        $query = "SELECT rss_id FROM news_rss_range WHERE range_id='$range_id'";
        return DBManager::get()
                ->query($query)
                ->fetchColumn();
    }

    public static function SetRssId($range_id, $type = false){
        if (!$type){
            $type = get_object_type($range_id);
            if ($type == 'fak') $type = 'inst';
        }
        $rss_id = md5('StudipRss'.$range_id);
        $affected_rows = DBManager::get()->exec("REPLACE INTO news_rss_range (range_id,rss_id,range_type) VALUES ('$range_id','$rss_id','$type')");
        return $affected_rows;
    }

    public static function  UnsetRssId($range_id){
        $affected_rows = DBManager::get()->exec("DELETE FROM news_rss_range WHERE range_id='$range_id'");
        return $affected_rows;
    }

    public static function GetAdminMsg($user_id, $date){
        return sprintf(_("Zuletzt aktualisiert von %s (%s) am %s"),get_fullname($user_id) ,get_username($user_id) ,date("d.m.y",$date));
    }

    public static function DoGarbageCollect(){
        $db = DBManager::get();
        if (!Config::GetInstance()->getValue('NEWS_DISABLE_GARBAGE_COLLECT')){
            $result = $db->query(
                                "SELECT news.news_id FROM news where (date+expire)<UNIX_TIMESTAMP()
                                UNION DISTINCT
                                SELECT news_range.news_id FROM news_range LEFT JOIN news USING (news_id) WHERE ISNULL(news.news_id)
                                UNION DISTINCT
                                SELECT news.news_id FROM news LEFT JOIN news_range USING (news_id) WHERE range_id IS NULL"
                                )->fetchAll(PDO::FETCH_COLUMN, 0);

            if (is_array($result)) {
                $kill_news = "('".join("','",$result)."')";
                $killed = $db->exec("DELETE FROM news WHERE news_id IN $kill_news");
                $db->exec("DELETE FROM news_range WHERE news_id IN $kill_news");
                object_kill_visits(null, $result);
                object_kill_views($result);
                StudipComments::DeleteCommentsByObject($result);
            }
            return $killed;
        }
    }

    public static function TouchNews($news_id, $touch_stamp = null){
        $ret = false;
        if(!$touch_stamp) $touch_stamp = time();
        $news = new StudipNews($news_id);
        if (!$news->isNew()) {
            $news->setValue('date', mktime(0,0,0,strftime("%m",$touch_stamp),strftime("%d",$touch_stamp),strftime("%y",$touch_stamp)));
            if (!$news->store()) {
                $news->triggerChdate();
            }
        }
        return $ret;
    }

    public static function DeleteNewsRanges($range_id){
        $ret = DBManager::get()->exec("DELETE FROM news_range WHERE range_id='$range_id'");
        StudipNews::DoGarbageCollect();
        return $ret;
    }

    public static function DeleteNewsByAuthor($user_id){
        foreach (StudipNews::GetNewsByAuthor($user_id, true) as $news){
            $deleted += $news->delete();
        }
        return $deleted;
    }

    /**
     *
     * @param string $id primary key of table
     */
    function __construct($id = null)
    {
        $this->db_table = 'news';
        $this->has_and_belongs_to_many['courses'] = array('class_name' => 'Course',
                                                           'thru_table' => 'news_range',
                                                           'thru_assoc_key' => 'range_id',
                                                           'on_delete' => 'delete',
                                                           'on_store' => null);
        $this->has_and_belongs_to_many['institutes'] = array('class_name' => 'Institute',
                                                           'thru_table' => 'news_range',
                                                           'thru_assoc_key' => 'range_id',
                                                           'on_delete' => 'delete',
                                                           'on_store' => null);
        $this->has_and_belongs_to_many['users'] = array('class_name' => 'AuthUserMd5',
                                                           'thru_table' => 'news_range',
                                                           'thru_assoc_key' => 'range_id',
                                                           'on_delete' => 'delete',
                                                           'on_store' => null);
        $this->has_one['globalrange'] = array('class_name' => 'GlobalNewsRange',
                                                            'assoc_foreign_key' => 'news_id',
                                                            'assoc_func' => 'find'
                                                           );
        $this->has_many['comments'] = array('class_name' => 'Comment',
                                            'assoc_foreign_key' => 'object_id',
                                            'on_delete' => 'delete',
                                            'on_store' => 'store');
        $this->belongs_to['owner'] = array('class_name' => 'User',
                                            'foreign_key' => 'user_id');
        $this->additional_fields['ranges'] = array('get' => 'getRanges');

        $this->registerCallback('before_delete', 'storeRanges');

        parent::__construct($id);
    }

    function restoreRanges() {
        foreach (array('courses', 'institutes', 'users', 'globalrange') as $r) {
            $this->resetRelation($r);
        }
        return count($this->ranges);
    }

    function getRanges() {
        $ranges = array();
        foreach (array('courses', 'institutes', 'users') as $r) {
            $ranges = array_merge($ranges, $this->{$r}->pluck('id'));
        }
        if ($this->globalrange->news_id) {
            $ranges[] = 'studip';
        }
        return $ranges;
    }

    function issetRange($range_id) {
        return array_search($range_id, $this->ranges) !== false;
    }

    function addRange($range_id) {
        if (!$this->issetRange($range_id)) {
            $object_type = get_object_type($range_id, array('sem','inst','user'));
            switch ($object_type) {
            case 'global':
                $this->globalrange = new GlobalNewsRange($this->news_id);
                return true;
                break;
            case 'sem':
                if ($course = Course::find($range_id)) {
                    $this->courses[] = $course;
                }
                return true;
                break;
            case 'user':
                if ($user = AuthUserMd5::find($range_id)) {
                    $this->users[] = $user;
                }
                return true;
                break;
            case 'inst':
            case 'fak':
                if ($inst = Institute::find($range_id)) {
                    $this->institutes[] = $inst;
                }
                return true;
                break;
            }
        } else {
            return false;
        }
    }

    function deleteRange($range_id) {
        if ($this->issetRange($range_id)) {
            if ($range_id === 'studip') {
                return $this->globalrange->news_id = null;
            } else {
                foreach (array('courses', 'institutes', 'users') as $r) {
                    if ($this->{$r}->unsetByPk($range_id) !== null) {
                        return true;
                    }
                }
            }
        } else {
            return false;
        }
    }

    function storeRanges()
    {
        $db = DBManager::get();
        $db->exec("DELETE FROM {$this->db_table}_range WHERE news_id='".$this->getId()."'");
        if (count($this->ranges)) {
            foreach($this->getRanges() as $range_id) {
                $db->exec("INSERT INTO {$this->db_table}_range SET range_id='$range_id',news_id='".$this->getId()."'");
            }
        }
        foreach (array('courses', 'institutes', 'users', 'globalrange') as $r) {
            $this->resetRelation($r);
        }
        return true;
    }

    function delete() {
        object_kill_visits(null, $this->getId());
        object_kill_views($this->getId());
        return parent::delete();
    }
}

class GlobalNewsRange extends SimpleORMap
{
    function __construct($news_id = null)
    {
        $this->db_table = 'news_range';
        $this->alias_fields['name'] = 'range_id';
        $this->registerCallback('after_initialize', 'cbAfterInitialize');
        if ($news_id !== null) {
            parent::__construct(array($news_id, 'studip'));
        } else {
            parent::__construct(null);
        }
    }

    protected function cbAfterInitialize()
    {
        $this->content['range_id'] = 'studip';
        $this->content_db['range_id'] = 'studip';
        return true;
    }
}
?>
